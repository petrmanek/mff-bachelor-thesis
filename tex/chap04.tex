\chapter{Library Documentation}~\label{chapter:documentation}
This chapter contains technical documentation of individual components of the library. To better illustrate some concepts, examples and code demonstrations are included.

The overall architecture of the library is based on generics and object polymorphism. Since the library offers object definitions as well as their implementation, it often defines Swift \textit{protocols} (similar to interfaces in other programming languages) or \textit{abstract classes}\footnote{In conventional programming languages, abstract classes contain unimplemented method definitions. Since Swift does not support this paradigm, it is emulated through the mechanism of static precondition failures.}, which are implemented by some of its objects. The purpose of this approach is to offer users a selection of ready-to-use building blocks as well as the option of customization, which is useful in certain cases.

The following sections define the object types representing chromosome data structures (Section~\ref{section:chromosomes}), population evaluators (Section~\ref{section:evaluation}), genetic operators (Section~\ref{section:genetic-operators}), selection objects (Section~\ref{section:selection}), termination conditions and event handlers (Section~\ref{section:execution}) and extensions (Section~\ref{section:extensions}).

\section{Chromosomes}~\label{section:chromosomes}
In the context of GA, a \textit{chromosome} (also known as \textit{genotype}) is a piece of information describing a solution to a problem. \cite{GaPracticalHandbook} Within the library, chromosomes can be represented by any reference types, which conform to the \texttt{ChromosomeType} protocol. This protocol requires them to
~
\begin{enumerate}
	\item be immutable,\footnote{This is a semantical requirement implying that every chromosome modification will require a new instance of the type to be created.}
	\item be capable of randomly generating new instances of themselves.\footnote{This is achieved by requiring conformance to the \texttt{Randomizable} protocol.}
\end{enumerate}

The upcoming sections explain why the choice of a good chromosome data structure is important in GA design (Section~\ref{section:data-representation-problem}), how to achieve common configurations for string-based (Section~\ref{section:strings}) and tree-based (Section~\ref{section:trees}) chromosomes, how to customize them for different applications and how to define custom data types for storing proprietary information (Section~\ref{section:custom-types}.

\subsection{Data Representation Problem}~\label{section:data-representation-problem}
When designing chromosome data structures, users first need to decide which information should be stored within chromosomes and how should such information be encoded into primitive types. These questions might not always be trivial to answer and it is possible to show that unfortunate choices could potentially impact the rate of convergence of the GA significantly. This is known as \textit{the problem of data representation}.

It is worth noting at this point that the complexity of this problem extends far beyond the scope of this work, and is thus not addressed. For more information on this topic, readers are referred to \cite{GaPracticalHandbook}.

\subsection{Strings}~\label{section:strings}
A popular method of storing chromosomes is to encode them as strings of values of the same type, e. g. binary or numeric. The library represents such strings in the form of \textit{range-initialized arrays}.

A range-initialized array is a generalization of a regular array. It is a generic list structure, which is capable of holding finite amounts of ordered homogeneous items. However, at the time of initialization, the number of elements in the array is set to a value, which randomly selected from a given number interval. This allows for more flexibility, since in some applications it is desirable to vary not only the contents of the chromosome, but also its size. If this behavior is not wanted, the array can be reconfigured to a constant length by specifying any interval of length zero.

A simple usage of range-initialized arrays can be demonstrated on finding solutions to the Knapsack Problem. Suppose that there are 10 things of different sizes and values and a knapsack of a limited capacity. The objective is to select things in order to maximize the total value of the knapsack contents, while not exceeding its capacity. Clearly, all solutions of this problem can be described as strings of 10 Boolean values, indicating whether items 1-10 are selected. These values can be stored in a range-initialized array with interval $[10;10]$, implying that the array has fixed size 10. The array class is declared in Listing \ref{listing:array-knapsack}.

\begin{listing}[ht]
	\inputswift{array-knapsack}
	\caption{Range-initialized array used to solve the Knapsack problem.}
	\label{listing:array-knapsack}
\end{listing}

In a similar way, range-initialized arrays can store integers to encode number sequences or floating-point decimals to describe connection weights of neural networks. Thanks to Swift type extensions, every instance of range-initialized array automatically conforms to the \texttt{ChromosomeType} protocol and supports three basic genetic operators (for definition, see Section \ref{section:genetic-operators}). Range-initialized arrays can thus be directly used as chromosomes in the GA without any further modification.

It is worth noting at this point that strings are \textbf{not designed to hold heterogeneous information}. In spite of that, it is possible to use them for such purpose. For instance, if a chromosome is required to contain numbers as well as bits, it can be encoded as a binary string, portions of which would be later interpreted\footnote{Interpretation can be performed in compliance with any known encoding, e. g. conventional signed encoding, BCD or the Gray code (RBC).} as integers by the application. While this approach succeeds in its purpose, it is strongly discouraged as it may also become a cause to various subsequent problems. For example, when applying genetic operators on the chromosome, the bundled implementation mutates range-initialized arrays by selecting a random element and modifying its value. In conventional situations, this is the desired behavior. However, if the algorithm happens to select an item of the array, which is merely a part of a greater whole (e. g. number), unfortunate modification of such item could cause the chromosome to become undecodable. Instead, the recommended alternative is to use custom types (see Section \ref{section:custom-types}), which not only avoid this issue, but also allow strongly-typed information to be checked at the time of compilation, discovering any possible type conversion errors.

\subsection{Trees}~\label{section:trees}
Tree structures are commonly used in applications, which require automatic code generation. In such applications, individuals often carry chromosomes which contain control programs, mathematical formulas or similar information that can be represented by tree graphs. The library allows to represent such type of data by a collection of \textit{tree nodes}.

A tree node is an abstract data structure, which can be configured to contain information of any type. In addition, tree nodes can point to multiple other tree nodes, linking the information they contain together, in order to form a forest. The library recognizes two fundamental types of tree nodes:
~
\begin{description}
	\item[Value Nodes (generic)]
	The purpose of a value node is to produce a value of some kind. While the means of producing the value may differ (e. g. constant, function or binary operation) as well as its type, every value node must offer a way to retrieve its value at runtime. This type of node is represented by the generic class \texttt{ValueNode<T>}.

	\item[Action Nodes]
	The purpose of an action node is to perform an action at runtime. The action may be a command of some kind, or may call other action, possibly requiring arguments in the form of other value nodes. This type of node is represented by the class \texttt{ActionNode}.
\end{description}

Both types of nodes are intentionally left abstract, guiding users to define their own node types for functions, operations and commands depending on their applications. This procedure is very simple and can be demonstrated on a maze robot simulation. Suppose that there is a robot, which can receive \texttt{WAIT}, \texttt{GO}, \texttt{STOP}, \texttt{TURN-LEFT} and \texttt{TURN-RIGHT} instructions in order to navigate a 2-dimensional maze. The robot is also capable of determining whether its front side is facing an obstacle. To auto-generate a control program for such robot, its instructions can be formalized as 5 subclasses the class \texttt{ActionNode} and the sensor output can be represented by a subclass of the class \texttt{ValueNode<Bool>}. Such formalization is shown in Listing \ref{listing:tree-maze}.

\begin{listing}[ht]
	\inputswift{tree-maze}
	\caption{Example implementation of the \texttt{GO} command action node.}
	\label{listing:tree-maze}
\end{listing}

\begin{figure}[ht]
	\centering
	\begin{tikzpicture}[sibling distance=10em,
	  every node/.style = {shape=rectangle, rounded corners,
	    draw, align=center,
	    top color=white, bottom color=blue!20}]]
	  \node {Root:\\\texttt{LoopNode}}
	    child { node {Termination:\\\texttt{ObstacleSensorNode}} }
	    child { node {Action:\\\texttt{SequenceNode}}
	      child { node {\texttt{GoCommandNode}}}
	      child { node {\texttt{WaitCommandNode}} } };
	\end{tikzpicture}
	\caption[Example program for the maze robot simulation.]{Example program for the maze robot simulation, which makes the robot go forward until it encounters an obstacle.}
	\label{figure:example-program}
\end{figure}


It is conceivable that combinations of various tree nodes can be translated into a language, which is similar to LISP in its architecture (as illustrated in Figure \ref{figure:example-program}). To produce fundamental building blocks of such language, \textit{a tree factory} object is required. Factories create new randomized instances of tree nodes, and can thus restrict or extend types of generated nodes depending on the application. The library contains various bundled node types, ready to use:
~
\begin{description} 
	\item[Constants]
	Constant nodes (\texttt{ConstantNode<T>}) contain constant values of any type, unchanging during program execution.

	\item[Operations]
	Operation nodes (descendants of classes \texttt{UnaryOperation<T1,T2>} and \texttt{BinaryOperation<T1,T2,T3>}) are generic templates for functions. Arguments of such functions are represented by other value node instances.

	\item[Comparisons]
	Comparison nodes represent equality (\texttt{EquationNode<T>}) and inequality predicates (\texttt{ComparisonNode<T>}), operating on tuples of other value node instances.

	\item[Arithmetic and Boolean Operations]
	For any numeric value nodes, addition, subtraction, multiplication, division and modulation are supported. In analogy, Boolean value nodes support negation, conjunction, disjunction, implication and equivalence.

	\item[Control-flow Primitives]
	Action nodes can be combined in sequences, loops or simple conditional expressions. Names of the node types responsible for this functionality are analogous to those listed above.
\end{description}

It is recommended that tree factories are instantiated in the global context, or in subclasses of entropy generators (see Listing \ref{listing:tree-factory}). Apart from controlling the type of generated nodes, factories allow to specify upper bounds of the depth and width of the tree, restricting the number of generated structures.

\begin{listing}[ht]
	\inputswift{tree-factory}
	\caption{Tree factory declared in an entropy generator subclass.}
	\label{listing:tree-factory}
\end{listing}

\subsection{Custom Types}~\label{section:custom-types}
If the chromosome information is not compatible with strings or trees, or is heterogeneous in its nature, it is recommended that a custom data type is declared to hold it. This allows users to label, document and describe individual parts of the chromosome, as well as to customize its behavior at important points of evaluation.

Any reference type can become a chromosome data structure, if it conforms to the \texttt{ChromosomeType} protocol (and its inherited protocols). No other protocol conformance is formally required. Nevertheless, it is worth noting that some genetic operators may require chromosomes to conform to other proprietary protocols, in order to operate on them. For instance, the \texttt{Mutable} protocol, which is required by the \texttt{Mutation} operator. For description of such protocols, see Section \ref{section:genetic-operators}.

Declaration of custom types can be demonstrated on The Hamburger Restaurant Problem, mentioned in the introduction\footnote{For the purposes of this work, the example has been slightly altered.} of \cite{Koza1992}. The objective is to find a business strategy for a chain of hamburger restaurants, which yields the biggest profit. A strategy consists of three decisions:
~
\begin{description}
	\item[Price]
	What should be the price of the hamburger? Should it be 50 cents, 10 dollars or anywhere in between?

	\item[Drink]
	What drink should be served with the hamburger? Water, cola or wine?

	\item[Speed of service]
	Should the restaurant provide slow, leisurely service by waiters in tuxedos or fast, snappy service by waiters in white polyester uniforms?
\end{description}

Clearly, every strategy is a heterogeneous data structure. Although it could be encoded into a binary string as proposed in Section \ref{section:strings}, it is much safer and more elegant to declare a dedicated type to hold its information. Such declaration is shown in Listing \ref{listing:hamburger-sample}.

\begin{listing}[ht]
	\inputswift{hamburger-sample}
	\caption{Example declaration of custom chromosome type.}
	\label{listing:hamburger-sample}
\end{listing}

Note that in the example declaration, every property is named and strongly-typed, clearing up any possible confusion about their purpose, and preventing type casting issues in the future. Moreover, the custom implementation of the randomization initializer allows users to specify clear bounds for fields, such as the hamburger price. Thanks to Swift generics, fields of type \texttt{Drink} and \texttt{Speed} can also be randomly initialized through the entropy generator, provided that they do conform to the \texttt{Randomizable} protocol. This way, the randomization call is propagated to all fields of the data structure.

Lastly, it is worth mentioning that types which are capable of listing all their possible values in a set of finite cardinality can utilize the \texttt{Discrete} protocol. This protocol functions as a simple time-saving shorthand for the \texttt{Randomizable} protocol, since it produces random values from the discrete uniform distribution of all values in the set. A good demonstration of this is a possible implementation of the \texttt{Drink} type, which is declared as a Swift enumeration in Listing \ref{listing:discrete-sample}.

\begin{listing}[ht]
	\inputswift{discrete-sample}
	\caption{Declaration of a chromosome type through a discrete listing of values.}
	\label{listing:discrete-sample}
\end{listing}

As shown by the demonstrations, declaration of custom types for heterogeneous chromosomes in Swift is effortless, safe and efficient. However, the reader should not be misled into thinking it only serves for creating nicely annotated vessels for information. This technique can be also used to create more complex genotype containers with customized behavior and proprietary internal structure, which is most notably exemplified by strings and trees, as both types are implemented in this way.

\section{Population Evaluation}~\label{section:evaluation}
In order to assess and compare the quality of chromosomes with respect to the optimization problem at hand, a common fitness evaluation model is used. In this model, every chromosome is assigned a value from the $[0;1]$ interval by a \textit{fitness function}, which is heavily dependent on the application and thus required to be specified by the user.

The fitness function (denoted $f$) is encapsulated in an \textit{evaluator} object, which is active for the entire duration of evaluation. The purpose of this encapsulation is to enable the possibility of accelerating the evaluation process by minimizing computing overhead needed to set up and tear down other components required to perform the evaluation itself. Since fitness functions often involve resource-expensive simulations and randomized testing scenarios, such optimization may be efficient in some cases.

The following sections explain the data structure which holds the evaluated chromosomes (Section~\ref{section:mating-pool}), the underlying base types of evaluator objects (Section~\ref{section:parallel-evaluators}) and the technique of nesting evaluators in order to perform statistical aggregation (Section~\ref{section:cyclic-evaluators}).

\subsection{Mating Pool}~\label{section:mating-pool}
In the context of population evaluation, a \textit{mating pool} represents a collection of individuals relevant to the current iteration of the GA. The pool is divided in two parts: the \textit{current generation} and the \textit{offspring}. Evaluators operate only on the first of these two.

Apart from chromosomes, individuals in the mating pool also have an optional field dedicated for their fitness value. When a new individual is inserted into the population, value of this field is not present. However, individuals transitioning between generations carry their previously set fitness with them. In a single iteration of the GA, the fundamental purpose of an evaluator object is to ensure that all individuals in the current generation have a non-null fitness value.

\subsection{Sequential and Parallel Evaluators}~\label{section:parallel-evaluators}
The library supports two evaluation modes: \textit{sequential} and \textit{parallel}. While the sequential mode is easier to implement but leads to slower evaluation, the parallel mode is faster but requires the internals of the fitness function to be compatible with multi-threaded processing, which may not always be feasible with respect to the problem definition.

To demonstrate implementation of a simple sequential evaluator, recall the chromosome structure, which was proposed earlier\footnote{The Knapsack Problem is defined in Section \ref{section:strings}. For chromosome, see Listing \ref{listing:array-knapsack}} for the Knapsack Problem. Suppose the fitness function is defined as
~
\begin{align}
	f(c_1, c_2, \dots, c_{10})
	=
	\begin{cases} 
		\hfill 0 \hfill & \text{ if $\sum_{i=1}^{10} c_i s_i>S_{max}$} \\
		\hfill \sum_{i=1}^{10} c_i v_i / \sum_{i=1}^{10} v_i \hfill & \text{ otherwise} \\
	\end{cases}
\end{align}

\noindent
where $S_{max}$ represents the maximum capacity of the knapsack, $\{s_i\}_{i=1}^{10}$ are sizes of things, $\{v_i\}_{i=1}^{10}$ are values of things and $\{c_i\}_{i=1}^{10}$ are 0/1 coefficients generated from the Boolean values of the chromosome. A simple implementation of a sequential evaluator using this function is shown in Listing \ref{listing:evaluator-sequential}.

\begin{listing}[ht]
	\inputswift{evaluator-sequential}
	\caption{Example of a sequential evaluator for the Knapsack Problem.}
	\label{listing:evaluator-sequential}
\end{listing}

In the example, the evaluator is a descendant of the generic abstract class \texttt{SequentialEvaluator<T>}, which is a common base class for all sequential evaluators. Similarly, all parallel evaluators have to be descendants of the class \texttt{ParallelEvaluator<T>}, which instantiates multiple sequential evaluators operating on different threads and manages internal producer-consumer queue to facilitate parallel evaluation of chromosomes. Moreover, both types of evaluators inherit from \texttt{Evaluator<T>}, an abstract class which defines the formal requirements on all evaluator objects.

When implementing fitness evaluator classes, it is recommended that the class \texttt{Evaluator<T>} is directly subclassed only in cases, when the evaluation scheme is incompatible the other already existing subclasses. A good example of such scenario would be an evaluator utilizing a distributed computing cluster. However, directly subclassing \texttt{Evaluator<T>} only to create a custom implementation of sequential evaluator is not advisable, since \texttt{SequentialEvaluator<T>} is integrated into other components of the library and avoiding its use would introduce subsequent issues.

\subsection{Cyclic Evaluators}~\label{section:cyclic-evaluators}
Every descendant of the class \texttt{SequentialEvaluator<T>} is eligible to be combined with a \textit{cyclic evaluator} (represented by the class \texttt{CyclicEvaluator<T>}). Instances of cyclic evaluators encapsulate other evaluators, which are called multiple times in order to evaluate a single chromosome. Such sub-evaluations are then statistically aggregated to produce a final fitness value. This procedure mimics a commonly used technique in GA fitness evaluation, which yields more stable and reliable fitness values, especially in randomized simulations.

Usage of cyclic evaluators is straightforward. At the instantiation time, a cyclic evaluator receives 3 parameters: a sequential evaluator, and numbers $n$ and $m$. Upon evaluation of an individual, the sequential evaluator is called $n$ times, producing a vector of $n$ fitness sub-evaluations. From this vector, $m$ of the highest (or the lowest) fitness values are then selected. The final fitness value returned by the cyclic evaluator is the average calculated from the selected values.

\section{Genetic Operators}~\label{section:genetic-operators}
Genetic operators are procedures, which are performed on collections of individuals during the evaluation of the GA in order to transition between iterations. When operators are applied, the entire mating pool is available to them. While the current generation can be merely accessed for reading, the offspring generation also supports writing. Every operator can thus read an arbitrary number of chromosomes from the current generation, and is expected to insert at least one chromosome into the offspring generation.

The selection of chromosomes is carried out through \textit{selection objects}, which are specified as configuration parameters of individual operators. There are various types of selections, each providing the selection pressure in a different way, thus being suitable for different classes of applications. For the description of supported selection methods, see Section \ref{section:selection}.

The library offers implementation of three common genetic operators: \textit{reproduction} (Section~\ref{section:reproduction}), \textit{mutation} (Section~\ref{section:mutation}) and \textit{crossover} (Section~\ref{section:crossover}). However, users are by no means limited to only these three. Section~\ref{section:custom-operators}) gives details and recommendations on creating custom operators. Lastly, the ways of combining genetic operators into decision trees are described in Section~\ref{section:decision-trees}.

\subsection{Reproduction}~\label{section:reproduction}
The reproduction operator mimics the asexual reproduction of natural organisms, which have survived long enough to mature. Unlike others, this operator does not introduce any novelty into the offspring generation. Instead, its purpose is to simply stabilize the population by carrying certain traits between generations. This in effect prevents the loss of diversity and thereby avoids premature convergence of the GA, which may lead to a suboptimal solution.

When applied on the population, the reproduction operator copies arbitrary number of selected chromosomes from the current generation to the next one without any modifications. Since the selection of individuals is independent of the operator implementation, it is technically possible to use any selection object with this operator. Nevertheless, it is worth noting that only fitness-proportionate strategies make sense in this context. A good example of such strategies is \textit{elitism}, which is more thoroughly described in Section \ref{section:elitism}.

Since individuals are immutable by definition, the operator requires their underlying chromosome data structures to conform to the \texttt{Reproducible} protocol in order to work properly. This protocol is a simple extension of the \texttt{Copyable} protocol, which requires types to be capable of producing deep copies of their instances.

\subsection{Mutation}~\label{section:mutation}
The mutation operator serves the desirable function of introducing occasional variety into a population and restoring its lost diversity. \cite{Koza1992} It is fundamentally similar to the reproduction operator, as it operates by copying selected chromosomes from the current generation to the next one. However before copying, the chromosomes are modified in a non-deterministic way (i.e. mutated), imitating random transcription errors during replication of genetic information in the nature. The degree of mutation in the chromosomes is static and determined by the implementation. In general, mutated chromosomes can be expected to mostly resemble their original counterparts, yet not be completely identical.

In order to be used in the GA, the mutation operator requires chromosome data structures to conform to the \texttt{Mutable} protocol. Every container can thus have its own, slightly different implementation of mutation, which should be defined in its documentation. General guidelines for implementing mutation are:
~
\begin{enumerate}
	\item Select one chromosome in the current generation.
	\item Choose a ``part'' of the chromosome at random.
	\item Copy the chromosome, substituting the chosen part for a randomly generated equivalent.
	\item Insert the modified chromosome into the offspring generation.
\end{enumerate}

Clearly, among various data structures the semantical definition of a ``part'' may differ. For instance, in range-initialized arrays, a part is defined as an item of the array. Since arrays are homogeneous, all their are equivalent by definition. In contrast, a part of a tree node structure is defined as a rooted subtree. Two subtrees are equivalent if the fundamental base classes of their root nodes match.

\subsection{Crossover}~\label{section:crossover}
The crossover operator emulates the act of sexual reproduction of individuals in the nature (also known as \textit{recombination}). Unlike the previous two operators, it requires the input of exactly two chromosomes from the current generation, which are referred to as \textit{the parent chromosomes}. During the execution of the operator, parts of the parent chromosomes are randomly chosen and exchanged, producing two new chromosomes, which are inserted into the offspring generation. These chromosomes carry a mixture of traits of the parent chromosomes, and can therefore be thought of as their \textit{children}.

Similarly to the mutation operator, in order for the crossover to be used with chromosomes, their underlying data structure must conform to a dedicated Swift protocol, which allows users to customize the behavior of the operator with respect to the architecture of the data structure. The general guidelines for implementing such customizations are:
~
\begin{enumerate}
	\item Select two distinct chromosomes in the current generation.
	\item Choose pairs of ``parts'' of the chromosomes at random.
	\item Copy both chromosomes, swapping the parts in each pair.
	\item Insert the modified chromosomes into the offspring generation.
\end{enumerate}

Depending on the number and size of interchanged parts, multiple classes of crossover operators\footnote{Each crossover operator has a dedicated Swift protocol.} can be defined. For arrays and range-initialized arrays, two crossovers are implemented:
~
\begin{description}
	\item[One-point crossover]
	A single point is randomly chosen to divide both arrays in two parts. While the first pair of parts is kept at its original position, the second pair is swapped. This crossover is represented by the protocol \texttt{OnePointCrossoverable}.

	\item[Two-point crossover]
	In analogous way to the one-point crossover, two points are randomly chosen to divide both arrays in three parts. The middle pair of parts is swapped between the chromosomes, whereas the remaining two pairs are left unmodified. This crossover is represented by the protocol \texttt{TwoPointCrossoverable}.
\end{description}

\subsection{Custom Operators}~\label{section:custom-operators}
By creating descendants of the generic abstract class \texttt{GeneticOperator<T>}, users are free to implement and experiment with any genetic operators of their own. This section gives details and recommendations on implementing such subclasses.

The base class contains a selection object and an initializer method, which is used to configure the selection at the time of creation. This initializer must be called from any descendants as it is crucial to operator execution later on. The internal logic of the operator is controlled by the abstract method \texttt{apply()}, which receives a mating pool and an entropy generator object. In this method, the operator is expected to call the selection object exactly once and provide it with both mentioned objects as well as the number of individuals needed for its execution. The selection then returns a list of the selected indices, which can be used to access the objects of individuals containing chromosome data and fitness evaluations. To further illustrate this approach, an example of a custom operator implementation is shown in Listing \ref{listing:custom-operator}.

\begin{listing}[ht]
	\inputswift{custom-operator}
	\caption{Example of a custom genetic operator implementation.}
	\label{listing:custom-operator}
\end{listing}

It is strongly recommended that genetic operators exert no additional selection logic on top of the results returned by the selection object. Instead, such logic is recommended to be resolved by creating custom selection objects, which are capable of encapsulating other selection objects. If required, this technique can be applied in the operator initializer, forcing all selections to undergo such encapsulation, as shown in Listing \ref{listing:selection-encapsulation}.

\begin{listing}[ht]
	\inputswift{selection-encapsulation}
	\caption{Example of a selection object encapsulation.}
	\label{listing:selection-encapsulation}
\end{listing}

In order to better work on the chromosome data structures, genetic operators can also define custom protocols, to which such structures can conform. By usage of Swift extensions, existing structures can be then altered to comply with any additional requirements specified by these protocols.

\subsection{Decision Trees}~\label{section:decision-trees}
Decision trees are used to describe the sequential application of operators in the GA. The library includes Swift syntax extensions to facilitate simple customization of such operator sequences. Two types of nodes are supported:
~
\begin{description}
	\item[Operator nodes]
	Operator nodes correspond to instances of application of genetic operators.

	\item[Chance nodes]
	Chance nodes contain non-deterministic switches between multiple choices. Every choice specifies its probability and a decision subtree to execute, should it be selected.
\end{description}

To ease their usage, decision trees are defined by custom Swift operators. In order to concatenate tree nodes in a sequence, the three-dash arrow operator (e.g. \texttt{--->}) is used. Sequences produced by this operator resemble linked lists in their structure. The three-bar operator (e.g. \texttt{|||}) serves to determine choices in chance nodes. The syntax of both operators is illustrated by Listing \ref{listing:decision-tree-definition}.

\begin{listing}[ht]
	\inputswift{pipeline-definition}
	\caption{Example of decision tree definition.}
	\label{listing:decision-tree-definition}
\end{listing}

\section{Selections}~\label{section:selection}
The purpose of selection objects is to separate the methods of chromosome selection from the genetic operators. This approach allows users to easily combine operators with selection methods without the need for unnecessary subclassing.

As input, selection objects receive three parameters from their genetic operators: the current generation (together with fitness evaluations), an entropy generator and the number of requested chromosomes. In return, selection objects are expected to produce a list of indices of the selected chromosomes or fail with error should the population contain insufficient number of chromosomes. When accessing fitness evaluations, the library uses lazy-loading optimizations, in order to prevent unnecessary sorting and data aggregation. For that reason, selection objects are not required to specify fitness-related dependencies. Instead, additional calculations are performed on the first instance when the information is required.

Similarly to genetic operators, the library offers the implementation of common selections: \textit{roulette selection} (Section~\ref{section:roulette-selection}), \textit{rank selection} (Section~\ref{section:rank-selection}), \textit{tournament selection} (Section~\ref{section:tournament-selection}) and several others (Section~\ref{section:miscellaneous}). In addition, the library allows its users to customize the behavior of selections, possibly creating their own subclasses (Section~\ref{section:custom-selection}).

\subsection{Roulette Selection}~\label{section:roulette-selection}
Roulette selection is one of the most basic fitness-proportionate selection methods used in the GA. When applied, each chromosome is assigned a normalized probability proportional to its current fitness value. Based on the assigned probabilities, a random generator then selects chromosomes from a discrete non-uniform distribution. This process can be likened to a spin of unfair roulette wheel, where every chromosome is allocated a sector with angle proportional to its fitness. \cite{GaConceptsDesigns}

The application of this method can be shown on a simple example. Suppose that there are four chromosomes with fitness values 0.05, 0.4, 0.8 and 0.1. In order to generate a distribution, the roulette selection method merely normalizes fitness values to sum up to 1. Chromosomes are therefore assigned probabilities 0.04, 0.3, 0.59 and 0.07 respectively.

In the library, roulette selection is represented by the \texttt{RouletteSelection} class, which has no arguments and can be combined with any genetic operator.

\subsection{Rank Selection}~\label{section:rank-selection}
Rank selection is a modification of the roulette selection method, which is better suited for cases with extreme differences in fitness values. In such situations, often a small group of fit chromosomes receives the majority of the roulette wheel, causing the rest of the population to be mostly neglected, thus leading to premature convergence of the GA.

To resolve these cases, rank selection first sorts all chromosomes by their current fitness values. Every chromosome is then assigned a probability proportional to its rank in the sequence (hence the name of the method). For example, if rank selection had been used instead of roulette, the chromosomes in the example from the previous section would be assigned ranks 1, 3, 4, 2 respectively. These ranks would be simply normalized to probabilities 0.1, 0.3, 0.4 and 0.2.

In the library, rank selection is represented by the \texttt{RankSelection} class, which has no arguments and can be combined with any genetic operator.

\subsection{Tournament Selection}~\label{section:tournament-selection}
Tournament selection provides selection pressure by holding a tournament among $s$ competitors, with $s$ being the tournament size (or order). The winner of the tournament is the chromosome with the highest fitness of the $s$ tournament competitors. \cite{GaTournamentSelection}

The library contains implementation of tournament selection, where competitors are chosen from the population by another selection object. By default, this secondary selection is random. However, by changing this argument, users can customize the behavior of the tournament selection significantly.

This selection method is represented by the \texttt{TournamentSelection} class, which receives the value of parameter $s$ and the secondary selection object upon instantiation, and can be combined with any genetic operator.

\subsection{Miscellaneous}~\label{section:miscellaneous}
In addition to the three methods described in previous sections, the library contains implementation of primitive selection objects, which serve as utilities for other selections or operators:
~
\begin{description}
	\item[Random selection]
	This method selects chromosomes at random with no regards to their fitness values. It is represented by the \texttt{RandomSelection} class, which has no arguments and can be combined with any genetic operator.

	\item[Best selection]
	This method deterministically selects chromosomes in the descending order of fitness values. It is represented by the \texttt{BestSelection} class, which has no arguments and can be combined with any genetic operator.

	\item[Worst selection]	
	This method deterministically selects chromosomes in the ascending order of fitness values. It is represented by the \texttt{WorstSelection} class, which has no arguments and can be combined with any genetic operator.
\end{description}

\subsection{Custom Selections}~\label{section:custom-selection}
To create a selection object for a custom selection method, users need to subclass the generic class \texttt{Selection<T>}.

The internal logic of any selection object is contained within the implementation of the abstract function \texttt{select()}. This function receives an entropy generator, a population, which serves as the domain for the selection, and the requested number of chromosomes to select. The expected output of the method is a set of zero-based indices pointing to the requested number of selected chromosomes in the population, which are not required to be distinct.

In the implementation of the method, users are free to assume that the fitness evaluation of all chromosomes is available.  Moreover, it possible to declare additional parameters or secondary selection objects during instantiation. If necessary, selection objects can also declare auxiliary protocols for chromosome types, in order to better integrate with their contents. A basic implementation of a custom selection object is shown in Listing \ref{listing:custom-selection}.

\begin{listing}[ht]
	\inputswift{custom-selection}
	\caption{Example of custom selection implementation.}
	\label{listing:custom-selection}
\end{listing}

\section{Execution}~\label{section:execution}
The library provides a simple interface for definition and configuration of the GA through the class \texttt{GeneticAlgorithm<T>}. In instances of this class, various components of the library come together to form a robust runtime environment for the execution of GA.

To configure the environment, the following parameters are required:
~
\begin{description}
	\item[Population size]
	The desired number of individuals in every generation of the mating pool. Since the number of individuals produced by genetic operators is not defined, the actual number of generated individuals may differ. In such cases, the value of this parameter serves as a lower bound to the actual value.

	\item[Decision Trees]
	The GA allows two decision trees to be specified. For reasons of clarity, these trees are labeled $\alpha$ and $\beta$. While the $\alpha$-tree is executed repeatedly at the beginning of every iteration of the GA, the $\beta$-tree is executed multiple times per iteration in order to populate the offspring generation. For more information, see Section~\ref{section:decision-trees}.

	\item[Evaluator]
	The evaluator object is instantiated for the entire duration of the execution of the GA. It receives requests to evaluate individuals in every iteration. For more information, see Section~\ref{section:evaluation}.

	\item[Termination condition]
	At the end of every iteration, the termination object is called to determine whether the GA should continue execution or terminate. For more information, see Section \ref{section:termination-conditions}.

	\item[Entropy generator]
	This object provides sequences of pseudorandom numbers used for non-deterministic parts of the GA. For more information, see Section \ref{section:entropy-generators}.
\end{description}

Once all dependencies are initialized, the GA is ready to commence execution. In this context, a single instance of execution is referred to as a \textit{run}. Runs are executed synchronously\footnote{Beware, the thread which calls the \texttt{run()} method is suspended until the execution finishes.} and are comprised of multiple iterations, depending on the termination condition. Each iteration consists of the following steps:
~
\begin{enumerate}
	\item Ensure that all individuals in the current generation are evaluated.
	\item Execute the $\alpha$-tree once.
	\item Reset the offspring generation.
	\item Execute the $\beta$-tree repeatedly until the offspring generation size is sufficient.
	\item Replace the current generation with the offspring.
\end{enumerate}

\subsection{Termination Conditions}~\label{section:termination-conditions}
Termination objects are descendants of the class \texttt{TerminationCondition<T>}. Their instances encapsulate Boolean functions, which determine whether the GA should terminate its execution upon the end of every iteration.

Objects provided by the library can be divided into two groups: the \textit{primitives} and the \textit{contractions}. The purpose of this division is to allow users to formulate complex termination conditions by combining primitives with the help of contractions. The supported primitives are:
~
\begin{description}
	\item[Fitness threshold]
	This condition terminates the execution of the GA once the best (or average) fitness in the population exceeds a set threshold. It is represented by the class \texttt{FitnessThreshold<T>}.

	\item[Maximum number of generations]
	This condition terminates the execution of the GA after a set number of iterations is performed. It is represented by the class \texttt{MaxNumberOfGenerations<T>}.

	\item[Termination date]
	This condition terminates the execution of the GA after a set date and time comes to pass. It is represented by the class \texttt{AfterDate<T>}.
\end{description}

Although every of the listed primitive objects can be used as a stand-alone termination condition, it is desirable to combine primitives using contractions. The library supports three basic contractions based on the fundamental logical operations. They are represented by classes \texttt{NotCondition<T>}, \texttt{AndCondition<T>} and \texttt{OrCondition<T>}. To simplify their usage, the library overloads common Swift Boolean operators \texttt{!}, \texttt{\&\&}, \texttt{||} in order to make them compatible with any descendants of \texttt{TerminationCondition<T>}. This is illustrated in Listing \ref{listing:termination-conditions}.

\begin{listing}[ht]
	\inputswift{termination-conditions}
	\caption{Example definitions of termination conditions.}
	\label{listing:termination-conditions}
\end{listing}

\subsection{Event Hooks}~\label{section:event-hooks}
Although the execution of the GA is synchronous on the level of individual runs, the library allows its users to directly respond to certain important events for the purposes of monitoring and logging. This is achieved by the application of a simple event-driven model.

Every event of interest declares a \textit{hook}. Hooks are optional function pointers, which can be set by the users to introduce custom logic into the evaluation scheme. By default, all hooks are unset when the GA is initialized. If the \texttt{DEBUG} macro is defined at the time of compilation, hooks are initialized with functions which print log messages to the standard output. Hooks for the following events are supported:
~
\begin{description}
	\item[Run started]
	This event occurs after the \texttt{run()} method is called, but before the first population of random individuals is generated. It is represented by the field \texttt{hookRunStarted}.

	\item[Run finished]
	This event occurs after the termination condition stops the execution of the algorithm, just before the \texttt{run()} method returns. It is represented by the field \texttt{hookRunFinished}.

	\item[Generation advanced]
	This event occurs after every iteration of the GA. At this point, all individuals are evaluated and values such as the best or average fitness of the generation can be accessed. It is represented by the field \texttt{hookGenerationAdvanced}.

	\item[Evaluation started]
	This event occurs after a new population of individuals is created, but before the evaluator object is called. It is represented by the field \texttt{hookEvaluationStarted}.

	\item[Individual evaluated]
	This event occurs after a single individual in the population was evaluated. It is represented by the field \texttt{hookEvaluationFinished}.

	\item[Evaluation finished]
	This event occurs after all individuals in the population were evaluated. It is represented by the field \texttt{hookEvaluationFinished}.
\end{description}

\section{Extensions}~\label{section:extensions}
In this section, several important extension functions of the library are described. These extensions are useful in practical applications as they mainly serve auxiliary purposes, easing the operation of the code, which interacts with the library and its components.

The following sections are dedicated to explaining how to enable elitism (Section~\ref{section:elitism}), save chromosomes into persistent storage (Section~\ref{section:persistence}) and how to customize the random generation algorithm used in the GA (Section~\ref{section:entropy-generators}).

\subsection{Elitism}~\label{section:elitism}
In practical applications, it is desirable to ensure that the quality of the solutions produced by the GA does not decrease over consecutive iterations. If the quality is defined as the highest fitness value of the individuals in the current generation, such effect can be simply achieved by copying the fittest individual from the current generation to the offspring generation before transitioning to the next iteration of the GA. This approach is known as \textit{elitism}.

The library provides a dedicated implementation of elitism represented by the class \texttt{Elitism<T>}, which is a simple restriction of the reproduction operator to the best individuals of the generation. For the best results, it is recommended that the class is directly referenced in the $\alpha$-tree of a genetic algorithm instance.

\subsection{Persistence}~\label{section:persistence}
To allow continued operation of the GA, the library supports serialization and deserialization of object values. This consequently allows users to persist the state of the GA, terminate their application and restart its execution later on at the same point. Data is serialized into the JavaScript Object Notation format (JSON), which is abstracted by the \texttt{SwiftyJSON} framework, one of the dependencies of the library.

In the code, every type that supports persistence is declared to conform to the \texttt{PersistentType} protocol, which requires it to provide additional encoding and decoding procedures. For user convenience, the majority of types provided by the library already conforms to this protocol. Only those types which are dependent on user subclassing often offer two protocols (or base classes), so that users can ultimately decide whether to support object persistence in accordance with their needs.

A good example of this division can be found in range-initialized arrays. In addition to the protocol \texttt{RangeInitializedArray<T>}, a persistent protocol \texttt{PersistentRangeInitializedArray<T>} is declared. The first protocol is a parent object to the latter. The only difference is that in the persistent version, type \texttt{T} is required to conform to \texttt{PersistentType}. In return, the entire persistent version of the range-initialized array also conforms to \texttt{PersistentType}, delegating serialization calls to its elements.

\subsection{Entropy Generators}~\label{section:entropy-generators}
Entropy generators are objects used to introduce non-deterministic behavior into the GA. In their essence, they represent a generalization of the conventional pseudo-random number generators (PRNG), extending the range of types produced beyond decimal numbers.

All entropy generators must conform to the \texttt{EntropyGenerator} protocol, which requires types to be capable of generating pseudo-random floating-point decimals in the $[0;1]$ interval. Any type can be randomly generated in a similar way, provided that it conforms to the \texttt{Randomizable} protocol. The library provides such extensions for many Swift primitive types including \texttt{Int}, \texttt{Double}, \texttt{Float}, \texttt{Bool} and enumerations, which can opt into this mechanism by conforming to the \texttt{Discrete} protocol as shown in Listing \ref{listing:discrete-sample}.

The library offers abstractions of random generation mechanisms provided by the standard library, most notably the \texttt{arc4random()} function (represented by \texttt{ArcGenerator}) and the \texttt{drand48()} function (represented by \texttt{DrandGenerator}). In addition, an implementation of the Mersenne Twister PRNG has been ported from an existing Python implementation (represented by \texttt{MersenneTwister}).
