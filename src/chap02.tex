\chapter{Library Implementation}
This chapter is a technical documentation of individual components of the library.

\section{Chromosome Data Structures}
In the context of genetic algorithms, \textit{a chromosome} (also known as \textit{genotype}) is a piece of information describing a solution to a problem. Since the nature and representation of such information depends on the application, the library allows full customization of the underlying data structures. Apart from that, the library also provides implementation of the most frequently used data structures. This leaves users free to decide, whether to use a structure supplied by the library, implement a custom one, or combine multiple data structures together.

The question of efficiently encoding solutions into chromosomes is a separate topic, worthy of further investigation. The library is merely intended as a tool to build containers for such chromosomes, once the user's mind is set on a specific method of data representation. This section explains, how to achieve some often used configurations, and how to define custom data types for storing proprietary information.

\subsection{Strings}
One of the most common ways of storing chromosomes is to encode them as strings of values of a same type, e. g. binary or numeric. Such strings are represented by \textit{range-initalized arrays}.

A range-initialized array is similar to a regular array in many ways. It is a generic list structure, which is capable of holding finite amounts of ordered homogoeneous values. However, at the time of initialization, the number of elements in the array is set to a value, which non-deterministically selected from a given interval. This allows for more flexibility, since in some applications, it is beneficial to vary not only the contents on the chromosome, but also its size. If this behavior is not required, the array can be configured to a constant length by using any interval of length zero.

A simple usage of range-initialized arrays can be demonstrated on the Knapsack Problem. Suppose that there are 10 things of different sizes and values and a knapsack of a limited capacity. The objective is to select things to maximize the value of knapsack contents, while not exceeeding its capacity. All solutions of this problem can be described as strings of 10 Boolean values, indicating whether items 1-10 are selected. These values can be stored in a range-initialized array of size $[10;10]$, which is declared in Listing \ref{listing:array-knapsack}.

\begin{listing}[ht]
	\inputminted{swift}{../code/array-knapsack.swift}
	\caption{Range-initialized array used to solve the Knapsack problem.}
	\label{listing:array-knapsack}
\end{listing}

In a similar way, range-initialized arrays can store integer tuples to encode permutations or floating-point decimals to describe weights of neural networks. Thanks to Swift extensions, every range-initialized array automatically supports three basic genetic operators (for definition, see section \ref{section:genetic-operators}) and can generate random instances of itself. Range-initialized arrays can thus be directly used as chromosomes in genetic algorithms.



\subsection{Trees}
\todo

\subsection{Custom Types}
\todo

\begin{listing}[ht]
\inputminted{swift}{../code/vector-sample.swift}
\caption{Example from external file}
\label{listing:3}
\end{listing}

\section{Genetic Operators}\label{section:genetic-operators}
\todo

\subsection{Reproduction}
\todo

\subsection{Mutation}
\todo

\subsection{Crossover}
\todo

\section{Selections}
\todo

\subsection{Roulette Selection}
\todo

\subsection{Rank Selection}
\todo

\subsection{Tournament Selection}
\todo

\subsection{Extensions}
\todo

\subsection{Optimizations}
\todo

\section{Algorithms}
\todo

\section{Event-driven Approach}
\todo

\section{Extensions}
\todo
